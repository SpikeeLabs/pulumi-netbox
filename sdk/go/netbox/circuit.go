// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package netbox

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// From the [official documentation](https://docs.netbox.dev/en/stable/core-functionality/circuits/#circuits_1):
//
// > A communications circuit represents a single physical link connecting exactly two endpoints, commonly referred to as its A and Z terminations. A circuit in NetBox may have zero, one, or two terminations defined. It is common to have only one termination defined when you don't necessarily care about the details of the provider side of the circuit, e.g. for Internet access circuits. Both terminations would likely be modeled for circuits which connect one customer site to another.
// >
// > Each circuit is associated with a provider and a user-defined type. For example, you might have Internet access circuits delivered to each site by one provider, and private MPLS circuits delivered by another. Each circuit must be assigned a circuit ID, each of which must be unique per provider.
type Circuit struct {
	pulumi.CustomResourceState

	Cid        pulumi.StringOutput `pulumi:"cid"`
	ProviderId pulumi.IntOutput    `pulumi:"providerId"`
	Status     pulumi.StringOutput `pulumi:"status"`
	TenantId   pulumi.IntPtrOutput `pulumi:"tenantId"`
	TypeId     pulumi.IntOutput    `pulumi:"typeId"`
}

// NewCircuit registers a new resource with the given unique name, arguments, and options.
func NewCircuit(ctx *pulumi.Context,
	name string, args *CircuitArgs, opts ...pulumi.ResourceOption) (*Circuit, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Cid == nil {
		return nil, errors.New("invalid value for required argument 'Cid'")
	}
	if args.ProviderId == nil {
		return nil, errors.New("invalid value for required argument 'ProviderId'")
	}
	if args.Status == nil {
		return nil, errors.New("invalid value for required argument 'Status'")
	}
	if args.TypeId == nil {
		return nil, errors.New("invalid value for required argument 'TypeId'")
	}
	var resource Circuit
	err := ctx.RegisterResource("netbox:index/circuit:Circuit", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCircuit gets an existing Circuit resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCircuit(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CircuitState, opts ...pulumi.ResourceOption) (*Circuit, error) {
	var resource Circuit
	err := ctx.ReadResource("netbox:index/circuit:Circuit", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Circuit resources.
type circuitState struct {
	Cid        *string `pulumi:"cid"`
	ProviderId *int    `pulumi:"providerId"`
	Status     *string `pulumi:"status"`
	TenantId   *int    `pulumi:"tenantId"`
	TypeId     *int    `pulumi:"typeId"`
}

type CircuitState struct {
	Cid        pulumi.StringPtrInput
	ProviderId pulumi.IntPtrInput
	Status     pulumi.StringPtrInput
	TenantId   pulumi.IntPtrInput
	TypeId     pulumi.IntPtrInput
}

func (CircuitState) ElementType() reflect.Type {
	return reflect.TypeOf((*circuitState)(nil)).Elem()
}

type circuitArgs struct {
	Cid        string `pulumi:"cid"`
	ProviderId int    `pulumi:"providerId"`
	Status     string `pulumi:"status"`
	TenantId   *int   `pulumi:"tenantId"`
	TypeId     int    `pulumi:"typeId"`
}

// The set of arguments for constructing a Circuit resource.
type CircuitArgs struct {
	Cid        pulumi.StringInput
	ProviderId pulumi.IntInput
	Status     pulumi.StringInput
	TenantId   pulumi.IntPtrInput
	TypeId     pulumi.IntInput
}

func (CircuitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*circuitArgs)(nil)).Elem()
}

type CircuitInput interface {
	pulumi.Input

	ToCircuitOutput() CircuitOutput
	ToCircuitOutputWithContext(ctx context.Context) CircuitOutput
}

func (*Circuit) ElementType() reflect.Type {
	return reflect.TypeOf((**Circuit)(nil)).Elem()
}

func (i *Circuit) ToCircuitOutput() CircuitOutput {
	return i.ToCircuitOutputWithContext(context.Background())
}

func (i *Circuit) ToCircuitOutputWithContext(ctx context.Context) CircuitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CircuitOutput)
}

// CircuitArrayInput is an input type that accepts CircuitArray and CircuitArrayOutput values.
// You can construct a concrete instance of `CircuitArrayInput` via:
//
//	CircuitArray{ CircuitArgs{...} }
type CircuitArrayInput interface {
	pulumi.Input

	ToCircuitArrayOutput() CircuitArrayOutput
	ToCircuitArrayOutputWithContext(context.Context) CircuitArrayOutput
}

type CircuitArray []CircuitInput

func (CircuitArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Circuit)(nil)).Elem()
}

func (i CircuitArray) ToCircuitArrayOutput() CircuitArrayOutput {
	return i.ToCircuitArrayOutputWithContext(context.Background())
}

func (i CircuitArray) ToCircuitArrayOutputWithContext(ctx context.Context) CircuitArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CircuitArrayOutput)
}

// CircuitMapInput is an input type that accepts CircuitMap and CircuitMapOutput values.
// You can construct a concrete instance of `CircuitMapInput` via:
//
//	CircuitMap{ "key": CircuitArgs{...} }
type CircuitMapInput interface {
	pulumi.Input

	ToCircuitMapOutput() CircuitMapOutput
	ToCircuitMapOutputWithContext(context.Context) CircuitMapOutput
}

type CircuitMap map[string]CircuitInput

func (CircuitMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Circuit)(nil)).Elem()
}

func (i CircuitMap) ToCircuitMapOutput() CircuitMapOutput {
	return i.ToCircuitMapOutputWithContext(context.Background())
}

func (i CircuitMap) ToCircuitMapOutputWithContext(ctx context.Context) CircuitMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CircuitMapOutput)
}

type CircuitOutput struct{ *pulumi.OutputState }

func (CircuitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Circuit)(nil)).Elem()
}

func (o CircuitOutput) ToCircuitOutput() CircuitOutput {
	return o
}

func (o CircuitOutput) ToCircuitOutputWithContext(ctx context.Context) CircuitOutput {
	return o
}

func (o CircuitOutput) Cid() pulumi.StringOutput {
	return o.ApplyT(func(v *Circuit) pulumi.StringOutput { return v.Cid }).(pulumi.StringOutput)
}

func (o CircuitOutput) ProviderId() pulumi.IntOutput {
	return o.ApplyT(func(v *Circuit) pulumi.IntOutput { return v.ProviderId }).(pulumi.IntOutput)
}

func (o CircuitOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *Circuit) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

func (o CircuitOutput) TenantId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Circuit) pulumi.IntPtrOutput { return v.TenantId }).(pulumi.IntPtrOutput)
}

func (o CircuitOutput) TypeId() pulumi.IntOutput {
	return o.ApplyT(func(v *Circuit) pulumi.IntOutput { return v.TypeId }).(pulumi.IntOutput)
}

type CircuitArrayOutput struct{ *pulumi.OutputState }

func (CircuitArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Circuit)(nil)).Elem()
}

func (o CircuitArrayOutput) ToCircuitArrayOutput() CircuitArrayOutput {
	return o
}

func (o CircuitArrayOutput) ToCircuitArrayOutputWithContext(ctx context.Context) CircuitArrayOutput {
	return o
}

func (o CircuitArrayOutput) Index(i pulumi.IntInput) CircuitOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Circuit {
		return vs[0].([]*Circuit)[vs[1].(int)]
	}).(CircuitOutput)
}

type CircuitMapOutput struct{ *pulumi.OutputState }

func (CircuitMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Circuit)(nil)).Elem()
}

func (o CircuitMapOutput) ToCircuitMapOutput() CircuitMapOutput {
	return o
}

func (o CircuitMapOutput) ToCircuitMapOutputWithContext(ctx context.Context) CircuitMapOutput {
	return o
}

func (o CircuitMapOutput) MapIndex(k pulumi.StringInput) CircuitOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Circuit {
		return vs[0].(map[string]*Circuit)[vs[1].(string)]
	}).(CircuitOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CircuitInput)(nil)).Elem(), &Circuit{})
	pulumi.RegisterInputType(reflect.TypeOf((*CircuitArrayInput)(nil)).Elem(), CircuitArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CircuitMapInput)(nil)).Elem(), CircuitMap{})
	pulumi.RegisterOutputType(CircuitOutput{})
	pulumi.RegisterOutputType(CircuitArrayOutput{})
	pulumi.RegisterOutputType(CircuitMapOutput{})
}
