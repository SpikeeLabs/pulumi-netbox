// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package netbox

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// From the [official documentation](https://docs.netbox.dev/en/stable/core-functionality/circuits/#circuit-types):
//
// > Circuits are classified by functional type. These types are completely customizable, and are typically used to convey the type of service being delivered over a circuit.
type CircuitType struct {
	pulumi.CustomResourceState

	Name pulumi.StringOutput `pulumi:"name"`
	Slug pulumi.StringOutput `pulumi:"slug"`
}

// NewCircuitType registers a new resource with the given unique name, arguments, and options.
func NewCircuitType(ctx *pulumi.Context,
	name string, args *CircuitTypeArgs, opts ...pulumi.ResourceOption) (*CircuitType, error) {
	if args == nil {
		args = &CircuitTypeArgs{}
	}

	var resource CircuitType
	err := ctx.RegisterResource("netbox:index/circuitType:CircuitType", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCircuitType gets an existing CircuitType resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCircuitType(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CircuitTypeState, opts ...pulumi.ResourceOption) (*CircuitType, error) {
	var resource CircuitType
	err := ctx.ReadResource("netbox:index/circuitType:CircuitType", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CircuitType resources.
type circuitTypeState struct {
	Name *string `pulumi:"name"`
	Slug *string `pulumi:"slug"`
}

type CircuitTypeState struct {
	Name pulumi.StringPtrInput
	Slug pulumi.StringPtrInput
}

func (CircuitTypeState) ElementType() reflect.Type {
	return reflect.TypeOf((*circuitTypeState)(nil)).Elem()
}

type circuitTypeArgs struct {
	Name *string `pulumi:"name"`
	Slug *string `pulumi:"slug"`
}

// The set of arguments for constructing a CircuitType resource.
type CircuitTypeArgs struct {
	Name pulumi.StringPtrInput
	Slug pulumi.StringPtrInput
}

func (CircuitTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*circuitTypeArgs)(nil)).Elem()
}

type CircuitTypeInput interface {
	pulumi.Input

	ToCircuitTypeOutput() CircuitTypeOutput
	ToCircuitTypeOutputWithContext(ctx context.Context) CircuitTypeOutput
}

func (*CircuitType) ElementType() reflect.Type {
	return reflect.TypeOf((**CircuitType)(nil)).Elem()
}

func (i *CircuitType) ToCircuitTypeOutput() CircuitTypeOutput {
	return i.ToCircuitTypeOutputWithContext(context.Background())
}

func (i *CircuitType) ToCircuitTypeOutputWithContext(ctx context.Context) CircuitTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CircuitTypeOutput)
}

// CircuitTypeArrayInput is an input type that accepts CircuitTypeArray and CircuitTypeArrayOutput values.
// You can construct a concrete instance of `CircuitTypeArrayInput` via:
//
//	CircuitTypeArray{ CircuitTypeArgs{...} }
type CircuitTypeArrayInput interface {
	pulumi.Input

	ToCircuitTypeArrayOutput() CircuitTypeArrayOutput
	ToCircuitTypeArrayOutputWithContext(context.Context) CircuitTypeArrayOutput
}

type CircuitTypeArray []CircuitTypeInput

func (CircuitTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CircuitType)(nil)).Elem()
}

func (i CircuitTypeArray) ToCircuitTypeArrayOutput() CircuitTypeArrayOutput {
	return i.ToCircuitTypeArrayOutputWithContext(context.Background())
}

func (i CircuitTypeArray) ToCircuitTypeArrayOutputWithContext(ctx context.Context) CircuitTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CircuitTypeArrayOutput)
}

// CircuitTypeMapInput is an input type that accepts CircuitTypeMap and CircuitTypeMapOutput values.
// You can construct a concrete instance of `CircuitTypeMapInput` via:
//
//	CircuitTypeMap{ "key": CircuitTypeArgs{...} }
type CircuitTypeMapInput interface {
	pulumi.Input

	ToCircuitTypeMapOutput() CircuitTypeMapOutput
	ToCircuitTypeMapOutputWithContext(context.Context) CircuitTypeMapOutput
}

type CircuitTypeMap map[string]CircuitTypeInput

func (CircuitTypeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CircuitType)(nil)).Elem()
}

func (i CircuitTypeMap) ToCircuitTypeMapOutput() CircuitTypeMapOutput {
	return i.ToCircuitTypeMapOutputWithContext(context.Background())
}

func (i CircuitTypeMap) ToCircuitTypeMapOutputWithContext(ctx context.Context) CircuitTypeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CircuitTypeMapOutput)
}

type CircuitTypeOutput struct{ *pulumi.OutputState }

func (CircuitTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CircuitType)(nil)).Elem()
}

func (o CircuitTypeOutput) ToCircuitTypeOutput() CircuitTypeOutput {
	return o
}

func (o CircuitTypeOutput) ToCircuitTypeOutputWithContext(ctx context.Context) CircuitTypeOutput {
	return o
}

func (o CircuitTypeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *CircuitType) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o CircuitTypeOutput) Slug() pulumi.StringOutput {
	return o.ApplyT(func(v *CircuitType) pulumi.StringOutput { return v.Slug }).(pulumi.StringOutput)
}

type CircuitTypeArrayOutput struct{ *pulumi.OutputState }

func (CircuitTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CircuitType)(nil)).Elem()
}

func (o CircuitTypeArrayOutput) ToCircuitTypeArrayOutput() CircuitTypeArrayOutput {
	return o
}

func (o CircuitTypeArrayOutput) ToCircuitTypeArrayOutputWithContext(ctx context.Context) CircuitTypeArrayOutput {
	return o
}

func (o CircuitTypeArrayOutput) Index(i pulumi.IntInput) CircuitTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CircuitType {
		return vs[0].([]*CircuitType)[vs[1].(int)]
	}).(CircuitTypeOutput)
}

type CircuitTypeMapOutput struct{ *pulumi.OutputState }

func (CircuitTypeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CircuitType)(nil)).Elem()
}

func (o CircuitTypeMapOutput) ToCircuitTypeMapOutput() CircuitTypeMapOutput {
	return o
}

func (o CircuitTypeMapOutput) ToCircuitTypeMapOutputWithContext(ctx context.Context) CircuitTypeMapOutput {
	return o
}

func (o CircuitTypeMapOutput) MapIndex(k pulumi.StringInput) CircuitTypeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CircuitType {
		return vs[0].(map[string]*CircuitType)[vs[1].(string)]
	}).(CircuitTypeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CircuitTypeInput)(nil)).Elem(), &CircuitType{})
	pulumi.RegisterInputType(reflect.TypeOf((*CircuitTypeArrayInput)(nil)).Elem(), CircuitTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CircuitTypeMapInput)(nil)).Elem(), CircuitTypeMap{})
	pulumi.RegisterOutputType(CircuitTypeOutput{})
	pulumi.RegisterOutputType(CircuitTypeArrayOutput{})
	pulumi.RegisterOutputType(CircuitTypeMapOutput{})
}
