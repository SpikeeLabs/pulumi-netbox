// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package netbox

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// From the [official documentation](https://docs.netbox.dev/en/stable/core-functionality/ipam/#aggregates):
//
// > NetBox allows us to specify the portions of IP space that are interesting to us by defining aggregates. Typically, an aggregate will correspond to either an allocation of public (globally routable) IP space granted by a regional authority, or a private (internally-routable) designation.
type Aggregate struct {
	pulumi.CustomResourceState

	Description pulumi.StringPtrOutput   `pulumi:"description"`
	Prefix      pulumi.StringOutput      `pulumi:"prefix"`
	RirId       pulumi.IntPtrOutput      `pulumi:"rirId"`
	Tags        pulumi.StringArrayOutput `pulumi:"tags"`
	TenantId    pulumi.IntPtrOutput      `pulumi:"tenantId"`
}

// NewAggregate registers a new resource with the given unique name, arguments, and options.
func NewAggregate(ctx *pulumi.Context,
	name string, args *AggregateArgs, opts ...pulumi.ResourceOption) (*Aggregate, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Prefix == nil {
		return nil, errors.New("invalid value for required argument 'Prefix'")
	}
	var resource Aggregate
	err := ctx.RegisterResource("netbox:index/aggregate:Aggregate", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAggregate gets an existing Aggregate resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAggregate(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AggregateState, opts ...pulumi.ResourceOption) (*Aggregate, error) {
	var resource Aggregate
	err := ctx.ReadResource("netbox:index/aggregate:Aggregate", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Aggregate resources.
type aggregateState struct {
	Description *string  `pulumi:"description"`
	Prefix      *string  `pulumi:"prefix"`
	RirId       *int     `pulumi:"rirId"`
	Tags        []string `pulumi:"tags"`
	TenantId    *int     `pulumi:"tenantId"`
}

type AggregateState struct {
	Description pulumi.StringPtrInput
	Prefix      pulumi.StringPtrInput
	RirId       pulumi.IntPtrInput
	Tags        pulumi.StringArrayInput
	TenantId    pulumi.IntPtrInput
}

func (AggregateState) ElementType() reflect.Type {
	return reflect.TypeOf((*aggregateState)(nil)).Elem()
}

type aggregateArgs struct {
	Description *string  `pulumi:"description"`
	Prefix      string   `pulumi:"prefix"`
	RirId       *int     `pulumi:"rirId"`
	Tags        []string `pulumi:"tags"`
	TenantId    *int     `pulumi:"tenantId"`
}

// The set of arguments for constructing a Aggregate resource.
type AggregateArgs struct {
	Description pulumi.StringPtrInput
	Prefix      pulumi.StringInput
	RirId       pulumi.IntPtrInput
	Tags        pulumi.StringArrayInput
	TenantId    pulumi.IntPtrInput
}

func (AggregateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*aggregateArgs)(nil)).Elem()
}

type AggregateInput interface {
	pulumi.Input

	ToAggregateOutput() AggregateOutput
	ToAggregateOutputWithContext(ctx context.Context) AggregateOutput
}

func (*Aggregate) ElementType() reflect.Type {
	return reflect.TypeOf((**Aggregate)(nil)).Elem()
}

func (i *Aggregate) ToAggregateOutput() AggregateOutput {
	return i.ToAggregateOutputWithContext(context.Background())
}

func (i *Aggregate) ToAggregateOutputWithContext(ctx context.Context) AggregateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregateOutput)
}

// AggregateArrayInput is an input type that accepts AggregateArray and AggregateArrayOutput values.
// You can construct a concrete instance of `AggregateArrayInput` via:
//
//	AggregateArray{ AggregateArgs{...} }
type AggregateArrayInput interface {
	pulumi.Input

	ToAggregateArrayOutput() AggregateArrayOutput
	ToAggregateArrayOutputWithContext(context.Context) AggregateArrayOutput
}

type AggregateArray []AggregateInput

func (AggregateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Aggregate)(nil)).Elem()
}

func (i AggregateArray) ToAggregateArrayOutput() AggregateArrayOutput {
	return i.ToAggregateArrayOutputWithContext(context.Background())
}

func (i AggregateArray) ToAggregateArrayOutputWithContext(ctx context.Context) AggregateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregateArrayOutput)
}

// AggregateMapInput is an input type that accepts AggregateMap and AggregateMapOutput values.
// You can construct a concrete instance of `AggregateMapInput` via:
//
//	AggregateMap{ "key": AggregateArgs{...} }
type AggregateMapInput interface {
	pulumi.Input

	ToAggregateMapOutput() AggregateMapOutput
	ToAggregateMapOutputWithContext(context.Context) AggregateMapOutput
}

type AggregateMap map[string]AggregateInput

func (AggregateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Aggregate)(nil)).Elem()
}

func (i AggregateMap) ToAggregateMapOutput() AggregateMapOutput {
	return i.ToAggregateMapOutputWithContext(context.Background())
}

func (i AggregateMap) ToAggregateMapOutputWithContext(ctx context.Context) AggregateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregateMapOutput)
}

type AggregateOutput struct{ *pulumi.OutputState }

func (AggregateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Aggregate)(nil)).Elem()
}

func (o AggregateOutput) ToAggregateOutput() AggregateOutput {
	return o
}

func (o AggregateOutput) ToAggregateOutputWithContext(ctx context.Context) AggregateOutput {
	return o
}

func (o AggregateOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Aggregate) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o AggregateOutput) Prefix() pulumi.StringOutput {
	return o.ApplyT(func(v *Aggregate) pulumi.StringOutput { return v.Prefix }).(pulumi.StringOutput)
}

func (o AggregateOutput) RirId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Aggregate) pulumi.IntPtrOutput { return v.RirId }).(pulumi.IntPtrOutput)
}

func (o AggregateOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Aggregate) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

func (o AggregateOutput) TenantId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Aggregate) pulumi.IntPtrOutput { return v.TenantId }).(pulumi.IntPtrOutput)
}

type AggregateArrayOutput struct{ *pulumi.OutputState }

func (AggregateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Aggregate)(nil)).Elem()
}

func (o AggregateArrayOutput) ToAggregateArrayOutput() AggregateArrayOutput {
	return o
}

func (o AggregateArrayOutput) ToAggregateArrayOutputWithContext(ctx context.Context) AggregateArrayOutput {
	return o
}

func (o AggregateArrayOutput) Index(i pulumi.IntInput) AggregateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Aggregate {
		return vs[0].([]*Aggregate)[vs[1].(int)]
	}).(AggregateOutput)
}

type AggregateMapOutput struct{ *pulumi.OutputState }

func (AggregateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Aggregate)(nil)).Elem()
}

func (o AggregateMapOutput) ToAggregateMapOutput() AggregateMapOutput {
	return o
}

func (o AggregateMapOutput) ToAggregateMapOutputWithContext(ctx context.Context) AggregateMapOutput {
	return o
}

func (o AggregateMapOutput) MapIndex(k pulumi.StringInput) AggregateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Aggregate {
		return vs[0].(map[string]*Aggregate)[vs[1].(string)]
	}).(AggregateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AggregateInput)(nil)).Elem(), &Aggregate{})
	pulumi.RegisterInputType(reflect.TypeOf((*AggregateArrayInput)(nil)).Elem(), AggregateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AggregateMapInput)(nil)).Elem(), AggregateMap{})
	pulumi.RegisterOutputType(AggregateOutput{})
	pulumi.RegisterOutputType(AggregateArrayOutput{})
	pulumi.RegisterOutputType(AggregateMapOutput{})
}
