// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package netbox

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// From the [official documentation](https://docs.netbox.dev/en/stable/core-functionality/virtualization/#cluster-groups):
//
// > Cluster groups may be created for the purpose of organizing clusters. The arrangement of clusters into groups is optional.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/hbjydev/pulumi-netbox/sdk/go/netbox"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := netbox.NewClusterGroup(ctx, "dcWest", &netbox.ClusterGroupArgs{
//				Description: pulumi.String("West Datacenter Cluster"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type ClusterGroup struct {
	pulumi.CustomResourceState

	Description pulumi.StringPtrOutput `pulumi:"description"`
	Name        pulumi.StringOutput    `pulumi:"name"`
	Slug        pulumi.StringOutput    `pulumi:"slug"`
}

// NewClusterGroup registers a new resource with the given unique name, arguments, and options.
func NewClusterGroup(ctx *pulumi.Context,
	name string, args *ClusterGroupArgs, opts ...pulumi.ResourceOption) (*ClusterGroup, error) {
	if args == nil {
		args = &ClusterGroupArgs{}
	}

	var resource ClusterGroup
	err := ctx.RegisterResource("netbox:index/clusterGroup:ClusterGroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetClusterGroup gets an existing ClusterGroup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetClusterGroup(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ClusterGroupState, opts ...pulumi.ResourceOption) (*ClusterGroup, error) {
	var resource ClusterGroup
	err := ctx.ReadResource("netbox:index/clusterGroup:ClusterGroup", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ClusterGroup resources.
type clusterGroupState struct {
	Description *string `pulumi:"description"`
	Name        *string `pulumi:"name"`
	Slug        *string `pulumi:"slug"`
}

type ClusterGroupState struct {
	Description pulumi.StringPtrInput
	Name        pulumi.StringPtrInput
	Slug        pulumi.StringPtrInput
}

func (ClusterGroupState) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterGroupState)(nil)).Elem()
}

type clusterGroupArgs struct {
	Description *string `pulumi:"description"`
	Name        *string `pulumi:"name"`
	Slug        *string `pulumi:"slug"`
}

// The set of arguments for constructing a ClusterGroup resource.
type ClusterGroupArgs struct {
	Description pulumi.StringPtrInput
	Name        pulumi.StringPtrInput
	Slug        pulumi.StringPtrInput
}

func (ClusterGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterGroupArgs)(nil)).Elem()
}

type ClusterGroupInput interface {
	pulumi.Input

	ToClusterGroupOutput() ClusterGroupOutput
	ToClusterGroupOutputWithContext(ctx context.Context) ClusterGroupOutput
}

func (*ClusterGroup) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGroup)(nil)).Elem()
}

func (i *ClusterGroup) ToClusterGroupOutput() ClusterGroupOutput {
	return i.ToClusterGroupOutputWithContext(context.Background())
}

func (i *ClusterGroup) ToClusterGroupOutputWithContext(ctx context.Context) ClusterGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGroupOutput)
}

// ClusterGroupArrayInput is an input type that accepts ClusterGroupArray and ClusterGroupArrayOutput values.
// You can construct a concrete instance of `ClusterGroupArrayInput` via:
//
//	ClusterGroupArray{ ClusterGroupArgs{...} }
type ClusterGroupArrayInput interface {
	pulumi.Input

	ToClusterGroupArrayOutput() ClusterGroupArrayOutput
	ToClusterGroupArrayOutputWithContext(context.Context) ClusterGroupArrayOutput
}

type ClusterGroupArray []ClusterGroupInput

func (ClusterGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClusterGroup)(nil)).Elem()
}

func (i ClusterGroupArray) ToClusterGroupArrayOutput() ClusterGroupArrayOutput {
	return i.ToClusterGroupArrayOutputWithContext(context.Background())
}

func (i ClusterGroupArray) ToClusterGroupArrayOutputWithContext(ctx context.Context) ClusterGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGroupArrayOutput)
}

// ClusterGroupMapInput is an input type that accepts ClusterGroupMap and ClusterGroupMapOutput values.
// You can construct a concrete instance of `ClusterGroupMapInput` via:
//
//	ClusterGroupMap{ "key": ClusterGroupArgs{...} }
type ClusterGroupMapInput interface {
	pulumi.Input

	ToClusterGroupMapOutput() ClusterGroupMapOutput
	ToClusterGroupMapOutputWithContext(context.Context) ClusterGroupMapOutput
}

type ClusterGroupMap map[string]ClusterGroupInput

func (ClusterGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClusterGroup)(nil)).Elem()
}

func (i ClusterGroupMap) ToClusterGroupMapOutput() ClusterGroupMapOutput {
	return i.ToClusterGroupMapOutputWithContext(context.Background())
}

func (i ClusterGroupMap) ToClusterGroupMapOutputWithContext(ctx context.Context) ClusterGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGroupMapOutput)
}

type ClusterGroupOutput struct{ *pulumi.OutputState }

func (ClusterGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGroup)(nil)).Elem()
}

func (o ClusterGroupOutput) ToClusterGroupOutput() ClusterGroupOutput {
	return o
}

func (o ClusterGroupOutput) ToClusterGroupOutputWithContext(ctx context.Context) ClusterGroupOutput {
	return o
}

func (o ClusterGroupOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterGroup) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o ClusterGroupOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ClusterGroup) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o ClusterGroupOutput) Slug() pulumi.StringOutput {
	return o.ApplyT(func(v *ClusterGroup) pulumi.StringOutput { return v.Slug }).(pulumi.StringOutput)
}

type ClusterGroupArrayOutput struct{ *pulumi.OutputState }

func (ClusterGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClusterGroup)(nil)).Elem()
}

func (o ClusterGroupArrayOutput) ToClusterGroupArrayOutput() ClusterGroupArrayOutput {
	return o
}

func (o ClusterGroupArrayOutput) ToClusterGroupArrayOutputWithContext(ctx context.Context) ClusterGroupArrayOutput {
	return o
}

func (o ClusterGroupArrayOutput) Index(i pulumi.IntInput) ClusterGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ClusterGroup {
		return vs[0].([]*ClusterGroup)[vs[1].(int)]
	}).(ClusterGroupOutput)
}

type ClusterGroupMapOutput struct{ *pulumi.OutputState }

func (ClusterGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClusterGroup)(nil)).Elem()
}

func (o ClusterGroupMapOutput) ToClusterGroupMapOutput() ClusterGroupMapOutput {
	return o
}

func (o ClusterGroupMapOutput) ToClusterGroupMapOutputWithContext(ctx context.Context) ClusterGroupMapOutput {
	return o
}

func (o ClusterGroupMapOutput) MapIndex(k pulumi.StringInput) ClusterGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ClusterGroup {
		return vs[0].(map[string]*ClusterGroup)[vs[1].(string)]
	}).(ClusterGroupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGroupInput)(nil)).Elem(), &ClusterGroup{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGroupArrayInput)(nil)).Elem(), ClusterGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGroupMapInput)(nil)).Elem(), ClusterGroupMap{})
	pulumi.RegisterOutputType(ClusterGroupOutput{})
	pulumi.RegisterOutputType(ClusterGroupArrayOutput{})
	pulumi.RegisterOutputType(ClusterGroupMapOutput{})
}
